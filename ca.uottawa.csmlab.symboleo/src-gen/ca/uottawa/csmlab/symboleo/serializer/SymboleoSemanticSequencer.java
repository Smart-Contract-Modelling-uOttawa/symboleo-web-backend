/*
 * generated by Xtext 2.31.0
 */
package ca.uottawa.csmlab.symboleo.serializer;

import ca.uottawa.csmlab.symboleo.services.SymboleoGrammarAccess;
import ca.uottawa.csmlab.symboleo.symboleo.Alias;
import ca.uottawa.csmlab.symboleo.symboleo.And;
import ca.uottawa.csmlab.symboleo.symboleo.AssignExpression;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDate;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDouble;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionEnum;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionFalse;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionInt;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionParameter;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionString;
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionTrue;
import ca.uottawa.csmlab.symboleo.symboleo.Attribute;
import ca.uottawa.csmlab.symboleo.symboleo.AttributeModifier;
import ca.uottawa.csmlab.symboleo.symboleo.BaseType;
import ca.uottawa.csmlab.symboleo.symboleo.Comparison;
import ca.uottawa.csmlab.symboleo.symboleo.ContractEvent;
import ca.uottawa.csmlab.symboleo.symboleo.ContractState;
import ca.uottawa.csmlab.symboleo.symboleo.Div;
import ca.uottawa.csmlab.symboleo.symboleo.EnumItem;
import ca.uottawa.csmlab.symboleo.symboleo.Enumeration;
import ca.uottawa.csmlab.symboleo.symboleo.Equality;
import ca.uottawa.csmlab.symboleo.symboleo.Interval;
import ca.uottawa.csmlab.symboleo.symboleo.IntervalFunction;
import ca.uottawa.csmlab.symboleo.symboleo.Minus;
import ca.uottawa.csmlab.symboleo.symboleo.Model;
import ca.uottawa.csmlab.symboleo.symboleo.Multi;
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPAtom;
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPrimaryExpression;
import ca.uottawa.csmlab.symboleo.symboleo.OAssignExpression;
import ca.uottawa.csmlab.symboleo.symboleo.Obligation;
import ca.uottawa.csmlab.symboleo.symboleo.ObligationEvent;
import ca.uottawa.csmlab.symboleo.symboleo.ObligationState;
import ca.uottawa.csmlab.symboleo.symboleo.OneArgMathFunction;
import ca.uottawa.csmlab.symboleo.symboleo.OneArgStringFunction;
import ca.uottawa.csmlab.symboleo.symboleo.OntologyType;
import ca.uottawa.csmlab.symboleo.symboleo.Or;
import ca.uottawa.csmlab.symboleo.symboleo.PAnd;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDateLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDoubleLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomEnum;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomFunction;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomIntLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicate;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateFalseLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateTrueLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomRecursive;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomStringLiteral;
import ca.uottawa.csmlab.symboleo.symboleo.PAtomVariable;
import ca.uottawa.csmlab.symboleo.symboleo.PComparison;
import ca.uottawa.csmlab.symboleo.symboleo.PEquality;
import ca.uottawa.csmlab.symboleo.symboleo.PFContractResumed;
import ca.uottawa.csmlab.symboleo.symboleo.PFContractSuspended;
import ca.uottawa.csmlab.symboleo.symboleo.PFContractTerminated;
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationDischarged;
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationResumed;
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationSuspended;
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTerminated;
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTriggered;
import ca.uottawa.csmlab.symboleo.symboleo.POr;
import ca.uottawa.csmlab.symboleo.symboleo.ParameterType;
import ca.uottawa.csmlab.symboleo.symboleo.Plus;
import ca.uottawa.csmlab.symboleo.symboleo.Point;
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomContractEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomObligationEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomParameterDotExpression;
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomPowerEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PointFunction;
import ca.uottawa.csmlab.symboleo.symboleo.Power;
import ca.uottawa.csmlab.symboleo.symboleo.PowerEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PowerState;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionAssignment;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionAssignmentOnly;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionCannotBeAssigned;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappens;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensAfter;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensWithin;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionIsEqual;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionIsOwner;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionOccurs;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBefore;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBeforeEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBefore;
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBeforeEvent;
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionFunctionCall;
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionRecursive;
import ca.uottawa.csmlab.symboleo.symboleo.RegularType;
import ca.uottawa.csmlab.symboleo.symboleo.SituationExpression;
import ca.uottawa.csmlab.symboleo.symboleo.SymboleoPackage;
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgDateFunction;
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgStringFunction;
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueInt;
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueVariable;
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgMathFunction;
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgStringFunction;
import ca.uottawa.csmlab.symboleo.symboleo.Variable;
import ca.uottawa.csmlab.symboleo.symboleo.VariableDotExpression;
import ca.uottawa.csmlab.symboleo.symboleo.VariableEvent;
import ca.uottawa.csmlab.symboleo.symboleo.VariableRef;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SymboleoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SymboleoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SymboleoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SymboleoPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case SymboleoPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case SymboleoPackage.ASSIGN_EXPRESSION:
				sequence_Assignment(context, (AssignExpression) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_DATE:
				sequence_AtomicExpression(context, (AtomicExpressionDate) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_DOUBLE:
				sequence_AtomicExpression(context, (AtomicExpressionDouble) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_ENUM:
				sequence_AtomicExpression(context, (AtomicExpressionEnum) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_FALSE:
				sequence_AtomicExpression(context, (AtomicExpressionFalse) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_INT:
				sequence_AtomicExpression(context, (AtomicExpressionInt) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_PARAMETER:
				sequence_AtomicExpression(context, (AtomicExpressionParameter) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_STRING:
				sequence_AtomicExpression(context, (AtomicExpressionString) semanticObject); 
				return; 
			case SymboleoPackage.ATOMIC_EXPRESSION_TRUE:
				sequence_AtomicExpression(context, (AtomicExpressionTrue) semanticObject); 
				return; 
			case SymboleoPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case SymboleoPackage.ATTRIBUTE_MODIFIER:
				sequence_AttributeModifier(context, (AttributeModifier) semanticObject); 
				return; 
			case SymboleoPackage.BASE_TYPE:
				sequence_BaseType(context, (BaseType) semanticObject); 
				return; 
			case SymboleoPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case SymboleoPackage.CONTRACT_EVENT:
				sequence_ContractEvent(context, (ContractEvent) semanticObject); 
				return; 
			case SymboleoPackage.CONTRACT_STATE:
				sequence_ContractState(context, (ContractState) semanticObject); 
				return; 
			case SymboleoPackage.DIV:
				sequence_Multiplication(context, (Div) semanticObject); 
				return; 
			case SymboleoPackage.ENUM_ITEM:
				sequence_EnumItem(context, (EnumItem) semanticObject); 
				return; 
			case SymboleoPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case SymboleoPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case SymboleoPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SymboleoPackage.INTERVAL_FUNCTION:
				sequence_IntervalExpression(context, (IntervalFunction) semanticObject); 
				return; 
			case SymboleoPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case SymboleoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SymboleoPackage.MULTI:
				sequence_Multiplication(context, (Multi) semanticObject); 
				return; 
			case SymboleoPackage.NEGATED_PATOM:
				sequence_PAtomicExpression(context, (NegatedPAtom) semanticObject); 
				return; 
			case SymboleoPackage.NEGATED_PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (NegatedPrimaryExpression) semanticObject); 
				return; 
			case SymboleoPackage.OASSIGN_EXPRESSION:
				sequence_OAssignment(context, (OAssignExpression) semanticObject); 
				return; 
			case SymboleoPackage.OBLIGATION:
				sequence_Obligation(context, (Obligation) semanticObject); 
				return; 
			case SymboleoPackage.OBLIGATION_EVENT:
				sequence_ObligationEvent(context, (ObligationEvent) semanticObject); 
				return; 
			case SymboleoPackage.OBLIGATION_STATE:
				sequence_ObligationState(context, (ObligationState) semanticObject); 
				return; 
			case SymboleoPackage.ONE_ARG_MATH_FUNCTION:
				sequence_MathFunction(context, (OneArgMathFunction) semanticObject); 
				return; 
			case SymboleoPackage.ONE_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (OneArgStringFunction) semanticObject); 
				return; 
			case SymboleoPackage.ONTOLOGY_TYPE:
				sequence_OntologyType(context, (OntologyType) semanticObject); 
				return; 
			case SymboleoPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case SymboleoPackage.PAND:
				sequence_PAnd(context, (PAnd) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_DATE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomDateLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_DOUBLE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomDoubleLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_ENUM:
				sequence_PAtomicExpression(context, (PAtomEnum) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_FUNCTION:
				sequence_PAtomicExpression(context, (PAtomFunction) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_INT_LITERAL:
				sequence_PAtomicExpression(context, (PAtomIntLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_PREDICATE:
				sequence_PAtomicExpression(context, (PAtomPredicate) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_PREDICATE_FALSE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomPredicateFalseLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_PREDICATE_TRUE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomPredicateTrueLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_RECURSIVE:
				sequence_PAtomicExpression(context, (PAtomRecursive) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_STRING_LITERAL:
				sequence_PAtomicExpression(context, (PAtomStringLiteral) semanticObject); 
				return; 
			case SymboleoPackage.PATOM_VARIABLE:
				sequence_PAtomicExpression(context, (PAtomVariable) semanticObject); 
				return; 
			case SymboleoPackage.PCOMPARISON:
				sequence_PComparison(context, (PComparison) semanticObject); 
				return; 
			case SymboleoPackage.PEQUALITY:
				sequence_PEquality(context, (PEquality) semanticObject); 
				return; 
			case SymboleoPackage.PF_CONTRACT_RESUMED:
				sequence_PowerFunction(context, (PFContractResumed) semanticObject); 
				return; 
			case SymboleoPackage.PF_CONTRACT_SUSPENDED:
				sequence_PowerFunction(context, (PFContractSuspended) semanticObject); 
				return; 
			case SymboleoPackage.PF_CONTRACT_TERMINATED:
				sequence_PowerFunction(context, (PFContractTerminated) semanticObject); 
				return; 
			case SymboleoPackage.PF_OBLIGATION_DISCHARGED:
				sequence_PowerFunction(context, (PFObligationDischarged) semanticObject); 
				return; 
			case SymboleoPackage.PF_OBLIGATION_RESUMED:
				sequence_PowerFunction(context, (PFObligationResumed) semanticObject); 
				return; 
			case SymboleoPackage.PF_OBLIGATION_SUSPENDED:
				sequence_PowerFunction(context, (PFObligationSuspended) semanticObject); 
				return; 
			case SymboleoPackage.PF_OBLIGATION_TERMINATED:
				sequence_PowerFunction(context, (PFObligationTerminated) semanticObject); 
				return; 
			case SymboleoPackage.PF_OBLIGATION_TRIGGERED:
				sequence_PowerFunction(context, (PFObligationTriggered) semanticObject); 
				return; 
			case SymboleoPackage.POR:
				sequence_POr(context, (POr) semanticObject); 
				return; 
			case SymboleoPackage.PARAMETER:
				sequence_Parameter(context, (ca.uottawa.csmlab.symboleo.symboleo.Parameter) semanticObject); 
				return; 
			case SymboleoPackage.PARAMETER_TYPE:
				sequence_ParameterType(context, (ParameterType) semanticObject); 
				return; 
			case SymboleoPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case SymboleoPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case SymboleoPackage.POINT_ATOM_CONTRACT_EVENT:
				sequence_PointAtom(context, (PointAtomContractEvent) semanticObject); 
				return; 
			case SymboleoPackage.POINT_ATOM_OBLIGATION_EVENT:
				sequence_PointAtom(context, (PointAtomObligationEvent) semanticObject); 
				return; 
			case SymboleoPackage.POINT_ATOM_PARAMETER_DOT_EXPRESSION:
				sequence_PointAtom(context, (PointAtomParameterDotExpression) semanticObject); 
				return; 
			case SymboleoPackage.POINT_ATOM_POWER_EVENT:
				sequence_PointAtom(context, (PointAtomPowerEvent) semanticObject); 
				return; 
			case SymboleoPackage.POINT_FUNCTION:
				sequence_PointFunction(context, (PointFunction) semanticObject); 
				return; 
			case SymboleoPackage.POWER:
				sequence_Power(context, (Power) semanticObject); 
				return; 
			case SymboleoPackage.POWER_EVENT:
				sequence_PowerEvent(context, (PowerEvent) semanticObject); 
				return; 
			case SymboleoPackage.POWER_STATE:
				sequence_PowerState(context, (PowerState) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_ASSIGNMENT:
				sequence_PredicateFunction(context, (PredicateFunctionAssignment) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_ASSIGNMENT_ONLY:
				sequence_PredicateFunction(context, (PredicateFunctionAssignmentOnly) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_CANNOT_BE_ASSIGNED:
				sequence_OtherFunction(context, (PredicateFunctionCannotBeAssigned) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_HAPPENS:
				sequence_PredicateFunction(context, (PredicateFunctionHappens) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_HAPPENS_AFTER:
				sequence_PredicateFunction(context, (PredicateFunctionHappensAfter) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_HAPPENS_WITHIN:
				sequence_PredicateFunction(context, (PredicateFunctionHappensWithin) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_IS_EQUAL:
				sequence_OtherFunction(context, (PredicateFunctionIsEqual) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_IS_OWNER:
				sequence_OtherFunction(context, (PredicateFunctionIsOwner) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_OCCURS:
				sequence_PredicateFunction(context, (PredicateFunctionOccurs) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_SHAPPENS_BEFORE:
				sequence_PredicateFunction(context, (PredicateFunctionSHappensBefore) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT:
				sequence_PredicateFunction(context, (PredicateFunctionSHappensBeforeEvent) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_WHAPPENS_BEFORE:
				sequence_PredicateFunction(context, (PredicateFunctionWHappensBefore) semanticObject); 
				return; 
			case SymboleoPackage.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT:
				sequence_PredicateFunction(context, (PredicateFunctionWHappensBeforeEvent) semanticObject); 
				return; 
			case SymboleoPackage.PRIMARY_EXPRESSION_FUNCTION_CALL:
				sequence_PrimaryExpression(context, (PrimaryExpressionFunctionCall) semanticObject); 
				return; 
			case SymboleoPackage.PRIMARY_EXPRESSION_RECURSIVE:
				sequence_PrimaryExpression(context, (PrimaryExpressionRecursive) semanticObject); 
				return; 
			case SymboleoPackage.REGULAR_TYPE:
				sequence_RegularType(context, (RegularType) semanticObject); 
				return; 
			case SymboleoPackage.SITUATION_EXPRESSION:
				sequence_IntervalExpression(context, (SituationExpression) semanticObject); 
				return; 
			case SymboleoPackage.THREE_ARG_DATE_FUNCTION:
				sequence_DateFunction(context, (ThreeArgDateFunction) semanticObject); 
				return; 
			case SymboleoPackage.THREE_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (ThreeArgStringFunction) semanticObject); 
				return; 
			case SymboleoPackage.TIMEVALUE_INT:
				sequence_Timevalue(context, (TimevalueInt) semanticObject); 
				return; 
			case SymboleoPackage.TIMEVALUE_VARIABLE:
				sequence_Timevalue(context, (TimevalueVariable) semanticObject); 
				return; 
			case SymboleoPackage.TWO_ARG_MATH_FUNCTION:
				sequence_MathFunction(context, (TwoArgMathFunction) semanticObject); 
				return; 
			case SymboleoPackage.TWO_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (TwoArgStringFunction) semanticObject); 
				return; 
			case SymboleoPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SymboleoPackage.VARIABLE_DOT_EXPRESSION:
				sequence_VariableDotExpression(context, (VariableDotExpression) semanticObject); 
				return; 
			case SymboleoPackage.VARIABLE_EVENT:
				sequence_VariableEvent(context, (VariableEvent) semanticObject); 
				return; 
			case SymboleoPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainType returns Alias
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     (name=ID type=BaseType)
	 * </pre>
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.DOMAIN_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.DOMAIN_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ALIAS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ALIAS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAliasAccess().getTypeBaseTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assignment returns AssignExpression
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, AssignExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ASSIGN_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ASSIGN_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ASSIGN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ASSIGN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionDate
	 *     Or returns AtomicExpressionDate
	 *     Or.Or_1_0 returns AtomicExpressionDate
	 *     And returns AtomicExpressionDate
	 *     And.And_1_0 returns AtomicExpressionDate
	 *     Equality returns AtomicExpressionDate
	 *     Equality.Equality_1_0 returns AtomicExpressionDate
	 *     Comparison returns AtomicExpressionDate
	 *     Comparison.Comparison_1_0 returns AtomicExpressionDate
	 *     Addition returns AtomicExpressionDate
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionDate
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionDate
	 *     Multiplication returns AtomicExpressionDate
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionDate
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionDate
	 *     PrimaryExpression returns AtomicExpressionDate
	 *     AtomicExpression returns AtomicExpressionDate
	 *
	 * Constraint:
	 *     value=Date
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionDate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_DATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_DATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDateParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionDouble
	 *     Or returns AtomicExpressionDouble
	 *     Or.Or_1_0 returns AtomicExpressionDouble
	 *     And returns AtomicExpressionDouble
	 *     And.And_1_0 returns AtomicExpressionDouble
	 *     Equality returns AtomicExpressionDouble
	 *     Equality.Equality_1_0 returns AtomicExpressionDouble
	 *     Comparison returns AtomicExpressionDouble
	 *     Comparison.Comparison_1_0 returns AtomicExpressionDouble
	 *     Addition returns AtomicExpressionDouble
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionDouble
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionDouble
	 *     Multiplication returns AtomicExpressionDouble
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionDouble
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionDouble
	 *     PrimaryExpression returns AtomicExpressionDouble
	 *     AtomicExpression returns AtomicExpressionDouble
	 *
	 * Constraint:
	 *     value=Double
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_DOUBLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_DOUBLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDoubleParserRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionEnum
	 *     Or returns AtomicExpressionEnum
	 *     Or.Or_1_0 returns AtomicExpressionEnum
	 *     And returns AtomicExpressionEnum
	 *     And.And_1_0 returns AtomicExpressionEnum
	 *     Equality returns AtomicExpressionEnum
	 *     Equality.Equality_1_0 returns AtomicExpressionEnum
	 *     Comparison returns AtomicExpressionEnum
	 *     Comparison.Comparison_1_0 returns AtomicExpressionEnum
	 *     Addition returns AtomicExpressionEnum
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionEnum
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionEnum
	 *     Multiplication returns AtomicExpressionEnum
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionEnum
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionEnum
	 *     PrimaryExpression returns AtomicExpressionEnum
	 *     AtomicExpression returns AtomicExpressionEnum
	 *
	 * Constraint:
	 *     (enumeration=[Enumeration|ID] enumItem=[EnumItem|ID])
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionEnum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUMERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUMERATION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getEnumerationEnumerationIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUMERATION, false));
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getEnumItemEnumItemIDTerminalRuleCall_5_3_0_1(), semanticObject.eGet(SymboleoPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUM_ITEM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionFalse
	 *     Or returns AtomicExpressionFalse
	 *     Or.Or_1_0 returns AtomicExpressionFalse
	 *     And returns AtomicExpressionFalse
	 *     And.And_1_0 returns AtomicExpressionFalse
	 *     Equality returns AtomicExpressionFalse
	 *     Equality.Equality_1_0 returns AtomicExpressionFalse
	 *     Comparison returns AtomicExpressionFalse
	 *     Comparison.Comparison_1_0 returns AtomicExpressionFalse
	 *     Addition returns AtomicExpressionFalse
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionFalse
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionFalse
	 *     Multiplication returns AtomicExpressionFalse
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionFalse
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionFalse
	 *     PrimaryExpression returns AtomicExpressionFalse
	 *     AtomicExpression returns AtomicExpressionFalse
	 *
	 * Constraint:
	 *     value='false'
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionFalse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_FALSE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_FALSE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueFalseKeyword_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionInt
	 *     Or returns AtomicExpressionInt
	 *     Or.Or_1_0 returns AtomicExpressionInt
	 *     And returns AtomicExpressionInt
	 *     And.And_1_0 returns AtomicExpressionInt
	 *     Equality returns AtomicExpressionInt
	 *     Equality.Equality_1_0 returns AtomicExpressionInt
	 *     Comparison returns AtomicExpressionInt
	 *     Comparison.Comparison_1_0 returns AtomicExpressionInt
	 *     Addition returns AtomicExpressionInt
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionInt
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionInt
	 *     Multiplication returns AtomicExpressionInt
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionInt
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionInt
	 *     PrimaryExpression returns AtomicExpressionInt
	 *     AtomicExpression returns AtomicExpressionInt
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueINTTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionParameter
	 *     Or returns AtomicExpressionParameter
	 *     Or.Or_1_0 returns AtomicExpressionParameter
	 *     And returns AtomicExpressionParameter
	 *     And.And_1_0 returns AtomicExpressionParameter
	 *     Equality returns AtomicExpressionParameter
	 *     Equality.Equality_1_0 returns AtomicExpressionParameter
	 *     Comparison returns AtomicExpressionParameter
	 *     Comparison.Comparison_1_0 returns AtomicExpressionParameter
	 *     Addition returns AtomicExpressionParameter
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionParameter
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionParameter
	 *     Multiplication returns AtomicExpressionParameter
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionParameter
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionParameter
	 *     PrimaryExpression returns AtomicExpressionParameter
	 *     AtomicExpression returns AtomicExpressionParameter
	 *
	 * Constraint:
	 *     value=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueVariableDotExpressionParserRuleCall_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionString
	 *     Or returns AtomicExpressionString
	 *     Or.Or_1_0 returns AtomicExpressionString
	 *     And returns AtomicExpressionString
	 *     And.And_1_0 returns AtomicExpressionString
	 *     Equality returns AtomicExpressionString
	 *     Equality.Equality_1_0 returns AtomicExpressionString
	 *     Comparison returns AtomicExpressionString
	 *     Comparison.Comparison_1_0 returns AtomicExpressionString
	 *     Addition returns AtomicExpressionString
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionString
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionString
	 *     Multiplication returns AtomicExpressionString
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionString
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionString
	 *     PrimaryExpression returns AtomicExpressionString
	 *     AtomicExpression returns AtomicExpressionString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionTrue
	 *     Or returns AtomicExpressionTrue
	 *     Or.Or_1_0 returns AtomicExpressionTrue
	 *     And returns AtomicExpressionTrue
	 *     And.And_1_0 returns AtomicExpressionTrue
	 *     Equality returns AtomicExpressionTrue
	 *     Equality.Equality_1_0 returns AtomicExpressionTrue
	 *     Comparison returns AtomicExpressionTrue
	 *     Comparison.Comparison_1_0 returns AtomicExpressionTrue
	 *     Addition returns AtomicExpressionTrue
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionTrue
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionTrue
	 *     Multiplication returns AtomicExpressionTrue
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionTrue
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionTrue
	 *     PrimaryExpression returns AtomicExpressionTrue
	 *     AtomicExpression returns AtomicExpressionTrue
	 *
	 * Constraint:
	 *     value='true'
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionTrue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_TRUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATOMIC_EXPRESSION_TRUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueTrueKeyword_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeModifier returns AttributeModifier
	 *
	 * Constraint:
	 *     name='Env'
	 * </pre>
	 */
	protected void sequence_AttributeModifier(ISerializationContext context, AttributeModifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ATTRIBUTE_MODIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ATTRIBUTE_MODIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeModifierAccess().getNameEnvKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     ((attributeModifier=AttributeModifier? name=ID baseType=BaseType) | (attributeModifier=AttributeModifier? name=ID domainType=[DomainType|ID]))
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BaseType returns BaseType
	 *
	 * Constraint:
	 *     (name='Number' | name='String' | name='Date' | name='Boolean')
	 * </pre>
	 */
	protected void sequence_BaseType(ISerializationContext context, BaseType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=Addition)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ContractEvent
	 *     ContractEvent returns ContractEvent
	 *
	 * Constraint:
	 *     eventName=ContractEventName
	 * </pre>
	 */
	protected void sequence_ContractEvent(ISerializationContext context, ContractEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.CONTRACT_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.CONTRACT_EVENT__EVENT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractEventAccess().getEventNameContractEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns ContractState
	 *     ContractState returns ContractState
	 *
	 * Constraint:
	 *     stateName=ContractStateName
	 * </pre>
	 */
	protected void sequence_ContractState(ISerializationContext context, ContractState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractStateAccess().getStateNameContractStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns ThreeArgDateFunction
	 *     DateFunction returns ThreeArgDateFunction
	 *
	 * Constraint:
	 *     (name='Date.add' arg1=Expression value=Expression timeUnit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_DateFunction(ISerializationContext context, ThreeArgDateFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.THREE_ARG_DATE_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.THREE_ARG_DATE_FUNCTION__VALUE));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.THREE_ARG_DATE_FUNCTION__TIME_UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.THREE_ARG_DATE_FUNCTION__TIME_UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateFunctionAccess().getNameDateAddKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDateFunctionAccess().getArg1ExpressionParserRuleCall_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getDateFunctionAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getDateFunctionAccess().getTimeUnitTimeUnitParserRuleCall_7_0(), semanticObject.getTimeUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumItem returns EnumItem
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EnumItem(ISerializationContext context, EnumItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.ENUM_ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.ENUM_ITEM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumItemAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainType returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID enumerationItems+=EnumItem* enumerationItems+=EnumItem)
	 * </pre>
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalExpression returns IntervalFunction
	 *
	 * Constraint:
	 *     (arg1=PointExpression arg2=PointExpression)
	 * </pre>
	 */
	protected void sequence_IntervalExpression(ISerializationContext context, IntervalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.INTERVAL_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.INTERVAL_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.INTERVAL_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.INTERVAL_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getArg1PointExpressionParserRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getArg2PointExpressionParserRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalExpression returns SituationExpression
	 *
	 * Constraint:
	 *     situation=Situation
	 * </pre>
	 */
	protected void sequence_IntervalExpression(ISerializationContext context, SituationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.SITUATION_EXPRESSION__SITUATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.SITUATION_EXPRESSION__SITUATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getSituationSituationParserRuleCall_1_1_0(), semanticObject.getSituation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     intervalExpression=IntervalExpression
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.INTERVAL__INTERVAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.INTERVAL__INTERVAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getIntervalExpressionIntervalExpressionParserRuleCall_0(), semanticObject.getIntervalExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns OneArgMathFunction
	 *     MathFunction returns OneArgMathFunction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='Math.abs' | 
	 *             name='Math.floor' | 
	 *             name='Math.cbrt' | 
	 *             name='Math.ceil' | 
	 *             name='Math.exp' | 
	 *             name='Math.sign' | 
	 *             name='Math.sqrt'
	 *         ) 
	 *         arg1=Expression
	 *     )
	 * </pre>
	 */
	protected void sequence_MathFunction(ISerializationContext context, OneArgMathFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns TwoArgMathFunction
	 *     MathFunction returns TwoArgMathFunction
	 *
	 * Constraint:
	 *     (name='Math.pow' arg1=Expression arg2=Expression)
	 * </pre>
	 */
	protected void sequence_MathFunction(ISerializationContext context, TwoArgMathFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.TWO_ARG_MATH_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.TWO_ARG_MATH_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathFunctionAccess().getNameMathPowKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMathFunctionAccess().getArg1ExpressionParserRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getMathFunctionAccess().getArg2ExpressionParserRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         domainName=ID 
	 *         domainTypes+=DomainType+ 
	 *         timeUnits=TimeUnit? 
	 *         contractName=ID 
	 *         parameters+=Parameter+ 
	 *         parameters+=Parameter 
	 *         variables+=Variable* 
	 *         preconditions+=Proposition* 
	 *         postconditions+=Proposition* 
	 *         obligations+=Obligation* 
	 *         survivingObligations+=Obligation* 
	 *         powers+=Power* 
	 *         constraints+=Proposition*
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     Addition returns Div
	 *     Addition.Plus_1_0_0_0 returns Div
	 *     Addition.Minus_1_0_1_0 returns Div
	 *     Multiplication returns Div
	 *     Multiplication.Multi_1_0_0_0 returns Div
	 *     Multiplication.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (left=Multiplication_Div_1_0_1_0 right=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Multi
	 *     Or returns Multi
	 *     Or.Or_1_0 returns Multi
	 *     And returns Multi
	 *     And.And_1_0 returns Multi
	 *     Equality returns Multi
	 *     Equality.Equality_1_0 returns Multi
	 *     Comparison returns Multi
	 *     Comparison.Comparison_1_0 returns Multi
	 *     Addition returns Multi
	 *     Addition.Plus_1_0_0_0 returns Multi
	 *     Addition.Minus_1_0_1_0 returns Multi
	 *     Multiplication returns Multi
	 *     Multiplication.Multi_1_0_0_0 returns Multi
	 *     Multiplication.Div_1_0_1_0 returns Multi
	 *
	 * Constraint:
	 *     (left=Multiplication_Multi_1_0_0_0 right=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multi semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.MULTI__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.MULTI__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.MULTI__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.MULTI__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OAssignment returns OAssignExpression
	 *
	 * Constraint:
	 *     (name2=VariableDotExpression op=':=' value=Expression)
	 * </pre>
	 */
	protected void sequence_OAssignment(ISerializationContext context, OAssignExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__NAME2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__NAME2));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OASSIGN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOAssignmentAccess().getName2VariableDotExpressionParserRuleCall_1_0(), semanticObject.getName2());
		feeder.accept(grammarAccess.getOAssignmentAccess().getOpColonEqualsSignKeyword_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOAssignmentAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ObligationEvent
	 *     ObligationEvent returns ObligationEvent
	 *
	 * Constraint:
	 *     (eventName=ObligationEventName obligationVariable=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_ObligationEvent(ISerializationContext context, ObligationEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OBLIGATION_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OBLIGATION_EVENT__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObligationEventAccess().getEventNameObligationEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getObligationEventAccess().getObligationVariableObligationIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns ObligationState
	 *     ObligationState returns ObligationState
	 *
	 * Constraint:
	 *     (stateName=ObligationStateName obligationVariable=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_ObligationState(ISerializationContext context, ObligationState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObligationStateAccess().getStateNameObligationStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.accept(grammarAccess.getObligationStateAccess().getObligationVariableObligationIDTerminalRuleCall_3_0_1(), semanticObject.eGet(SymboleoPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Obligation returns Obligation
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         trigger=Proposition? 
	 *         debtor=VariableDotExpression 
	 *         creditor=VariableDotExpression 
	 *         antecedent=Proposition 
	 *         consequent=Proposition
	 *     )
	 * </pre>
	 */
	protected void sequence_Obligation(ISerializationContext context, Obligation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OntologyType returns OntologyType
	 *
	 * Constraint:
	 *     (name='Asset' | name='Event' | name='Role' | name='Contract')
	 * </pre>
	 */
	protected void sequence_OntologyType(ISerializationContext context, OntologyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionCannotBeAssigned
	 *
	 * Constraint:
	 *     (name='CannotBeAssigned' arg1=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionCannotBeAssigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameCannotBeAssignedKeyword_2_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_2_3_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionIsEqual
	 *
	 * Constraint:
	 *     (name='IsEqual' arg1=ID arg2=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionIsEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_IS_EQUAL__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_IS_EQUAL__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameIsEqualKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg2IDTerminalRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionIsOwner
	 *
	 * Constraint:
	 *     (name='IsOwner' arg1=ID arg2=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionIsOwner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.OTHER_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_IS_OWNER__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_IS_OWNER__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameIsOwnerKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_1_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg2IDTerminalRuleCall_1_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAnd
	 *     POr returns PAnd
	 *     POr.POr_1_0 returns PAnd
	 *     PAnd returns PAnd
	 *     PAnd.PAnd_1_0 returns PAnd
	 *
	 * Constraint:
	 *     (left=PAnd_PAnd_1_0 right=PEquality)
	 * </pre>
	 */
	protected void sequence_PAnd(ISerializationContext context, PAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PAND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PAND__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PAND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PAND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAndAccess().getPAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPAndAccess().getRightPEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns NegatedPAtom
	 *     POr returns NegatedPAtom
	 *     POr.POr_1_0 returns NegatedPAtom
	 *     PAnd returns NegatedPAtom
	 *     PAnd.PAnd_1_0 returns NegatedPAtom
	 *     PEquality returns NegatedPAtom
	 *     PEquality.PEquality_1_0 returns NegatedPAtom
	 *     PComparison returns NegatedPAtom
	 *     PComparison.PComparison_1_0 returns NegatedPAtom
	 *     PAtomicExpression returns NegatedPAtom
	 *
	 * Constraint:
	 *     negated=PAtomicExpression
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, NegatedPAtom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.NEGATED_PATOM__NEGATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.NEGATED_PATOM__NEGATED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getNegatedPAtomicExpressionParserRuleCall_1_2_0(), semanticObject.getNegated());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomDateLiteral
	 *     POr returns PAtomDateLiteral
	 *     POr.POr_1_0 returns PAtomDateLiteral
	 *     PAnd returns PAtomDateLiteral
	 *     PAnd.PAnd_1_0 returns PAtomDateLiteral
	 *     PEquality returns PAtomDateLiteral
	 *     PEquality.PEquality_1_0 returns PAtomDateLiteral
	 *     PComparison returns PAtomDateLiteral
	 *     PComparison.PComparison_1_0 returns PAtomDateLiteral
	 *     PAtomicExpression returns PAtomDateLiteral
	 *
	 * Constraint:
	 *     value=Date
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomDateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_DATE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_DATE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueDateParserRuleCall_11_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomDoubleLiteral
	 *     POr returns PAtomDoubleLiteral
	 *     POr.POr_1_0 returns PAtomDoubleLiteral
	 *     PAnd returns PAtomDoubleLiteral
	 *     PAnd.PAnd_1_0 returns PAtomDoubleLiteral
	 *     PEquality returns PAtomDoubleLiteral
	 *     PEquality.PEquality_1_0 returns PAtomDoubleLiteral
	 *     PComparison returns PAtomDoubleLiteral
	 *     PComparison.PComparison_1_0 returns PAtomDoubleLiteral
	 *     PAtomicExpression returns PAtomDoubleLiteral
	 *
	 * Constraint:
	 *     value=Double
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomDoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueDoubleParserRuleCall_8_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomEnum
	 *     POr returns PAtomEnum
	 *     POr.POr_1_0 returns PAtomEnum
	 *     PAnd returns PAtomEnum
	 *     PAnd.PAnd_1_0 returns PAtomEnum
	 *     PEquality returns PAtomEnum
	 *     PEquality.PEquality_1_0 returns PAtomEnum
	 *     PComparison returns PAtomEnum
	 *     PComparison.PComparison_1_0 returns PAtomEnum
	 *     PAtomicExpression returns PAtomEnum
	 *
	 * Constraint:
	 *     (enumeration=[Enumeration|ID] enumItem=[EnumItem|ID])
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomEnum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_ENUM__ENUMERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_ENUM__ENUMERATION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_ENUM__ENUM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_ENUM__ENUM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getEnumerationEnumerationIDTerminalRuleCall_4_1_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PATOM_ENUM__ENUMERATION, false));
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getEnumItemEnumItemIDTerminalRuleCall_4_3_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PATOM_ENUM__ENUM_ITEM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomFunction
	 *     POr returns PAtomFunction
	 *     POr.POr_1_0 returns PAtomFunction
	 *     PAnd returns PAtomFunction
	 *     PAnd.PAnd_1_0 returns PAtomFunction
	 *     PEquality returns PAtomFunction
	 *     PEquality.PEquality_1_0 returns PAtomFunction
	 *     PComparison returns PAtomFunction
	 *     PComparison.PComparison_1_0 returns PAtomFunction
	 *     PAtomicExpression returns PAtomFunction
	 *
	 * Constraint:
	 *     function=OtherFunction
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_FUNCTION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_FUNCTION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getFunctionOtherFunctionParserRuleCall_3_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomIntLiteral
	 *     POr returns PAtomIntLiteral
	 *     POr.POr_1_0 returns PAtomIntLiteral
	 *     PAnd returns PAtomIntLiteral
	 *     PAnd.PAnd_1_0 returns PAtomIntLiteral
	 *     PEquality returns PAtomIntLiteral
	 *     PEquality.PEquality_1_0 returns PAtomIntLiteral
	 *     PComparison returns PAtomIntLiteral
	 *     PComparison.PComparison_1_0 returns PAtomIntLiteral
	 *     PAtomicExpression returns PAtomIntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomIntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueINTTerminalRuleCall_9_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicate
	 *     POr returns PAtomPredicate
	 *     POr.POr_1_0 returns PAtomPredicate
	 *     PAnd returns PAtomPredicate
	 *     PAnd.PAnd_1_0 returns PAtomPredicate
	 *     PEquality returns PAtomPredicate
	 *     PEquality.PEquality_1_0 returns PAtomPredicate
	 *     PComparison returns PAtomPredicate
	 *     PComparison.PComparison_1_0 returns PAtomPredicate
	 *     PAtomicExpression returns PAtomPredicate
	 *
	 * Constraint:
	 *     predicateFunction=PredicateFunction
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE__PREDICATE_FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE__PREDICATE_FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getPredicateFunctionPredicateFunctionParserRuleCall_2_1_0(), semanticObject.getPredicateFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicateFalseLiteral
	 *     POr returns PAtomPredicateFalseLiteral
	 *     POr.POr_1_0 returns PAtomPredicateFalseLiteral
	 *     PAnd returns PAtomPredicateFalseLiteral
	 *     PAnd.PAnd_1_0 returns PAtomPredicateFalseLiteral
	 *     PEquality returns PAtomPredicateFalseLiteral
	 *     PEquality.PEquality_1_0 returns PAtomPredicateFalseLiteral
	 *     PComparison returns PAtomPredicateFalseLiteral
	 *     PComparison.PComparison_1_0 returns PAtomPredicateFalseLiteral
	 *     PAtomicExpression returns PAtomPredicateFalseLiteral
	 *
	 * Constraint:
	 *     value='false'
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicateFalseLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE_FALSE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE_FALSE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueFalseKeyword_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicateTrueLiteral
	 *     POr returns PAtomPredicateTrueLiteral
	 *     POr.POr_1_0 returns PAtomPredicateTrueLiteral
	 *     PAnd returns PAtomPredicateTrueLiteral
	 *     PAnd.PAnd_1_0 returns PAtomPredicateTrueLiteral
	 *     PEquality returns PAtomPredicateTrueLiteral
	 *     PEquality.PEquality_1_0 returns PAtomPredicateTrueLiteral
	 *     PComparison returns PAtomPredicateTrueLiteral
	 *     PComparison.PComparison_1_0 returns PAtomPredicateTrueLiteral
	 *     PAtomicExpression returns PAtomPredicateTrueLiteral
	 *
	 * Constraint:
	 *     value='true'
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicateTrueLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE_TRUE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_PREDICATE_TRUE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueTrueKeyword_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomRecursive
	 *     POr returns PAtomRecursive
	 *     POr.POr_1_0 returns PAtomRecursive
	 *     PAnd returns PAtomRecursive
	 *     PAnd.PAnd_1_0 returns PAtomRecursive
	 *     PEquality returns PAtomRecursive
	 *     PEquality.PEquality_1_0 returns PAtomRecursive
	 *     PComparison returns PAtomRecursive
	 *     PComparison.PComparison_1_0 returns PAtomRecursive
	 *     PAtomicExpression returns PAtomRecursive
	 *
	 * Constraint:
	 *     inner=Proposition
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomRecursive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_RECURSIVE__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_RECURSIVE__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getInnerPropositionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomStringLiteral
	 *     POr returns PAtomStringLiteral
	 *     POr.POr_1_0 returns PAtomStringLiteral
	 *     PAnd returns PAtomStringLiteral
	 *     PAnd.PAnd_1_0 returns PAtomStringLiteral
	 *     PEquality returns PAtomStringLiteral
	 *     PEquality.PEquality_1_0 returns PAtomStringLiteral
	 *     PComparison returns PAtomStringLiteral
	 *     PComparison.PComparison_1_0 returns PAtomStringLiteral
	 *     PAtomicExpression returns PAtomStringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomStringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_10_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomVariable
	 *     POr returns PAtomVariable
	 *     POr.POr_1_0 returns PAtomVariable
	 *     PAnd returns PAtomVariable
	 *     PAnd.PAnd_1_0 returns PAtomVariable
	 *     PEquality returns PAtomVariable
	 *     PEquality.PEquality_1_0 returns PAtomVariable
	 *     PComparison returns PAtomVariable
	 *     PComparison.PComparison_1_0 returns PAtomVariable
	 *     PAtomicExpression returns PAtomVariable
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PATOM_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PATOM_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getVariableVariableDotExpressionParserRuleCall_5_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PComparison
	 *     POr returns PComparison
	 *     POr.POr_1_0 returns PComparison
	 *     PAnd returns PComparison
	 *     PAnd.PAnd_1_0 returns PComparison
	 *     PEquality returns PComparison
	 *     PEquality.PEquality_1_0 returns PComparison
	 *     PComparison returns PComparison
	 *     PComparison.PComparison_1_0 returns PComparison
	 *
	 * Constraint:
	 *     (left=PComparison_PComparison_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=PAtomicExpression)
	 * </pre>
	 */
	protected void sequence_PComparison(ISerializationContext context, PComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PEquality
	 *     POr returns PEquality
	 *     POr.POr_1_0 returns PEquality
	 *     PAnd returns PEquality
	 *     PAnd.PAnd_1_0 returns PEquality
	 *     PEquality returns PEquality
	 *     PEquality.PEquality_1_0 returns PEquality
	 *
	 * Constraint:
	 *     (left=PEquality_PEquality_1_0 (op='==' | op='!=') right=PComparison)
	 * </pre>
	 */
	protected void sequence_PEquality(ISerializationContext context, PEquality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns POr
	 *     POr returns POr
	 *     POr.POr_1_0 returns POr
	 *
	 * Constraint:
	 *     (left=POr_POr_1_0 right=PAnd)
	 * </pre>
	 */
	protected void sequence_POr(ISerializationContext context, POr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPOrAccess().getPOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPOrAccess().getRightPAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns ParameterType
	 *
	 * Constraint:
	 *     (baseType=BaseType | domainType=[DomainType|ID])
	 * </pre>
	 */
	protected void sequence_ParameterType(ISerializationContext context, ParameterType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=ParameterType)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, ca.uottawa.csmlab.symboleo.symboleo.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeParameterTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomContractEvent
	 *     PointAtom returns PointAtomContractEvent
	 *
	 * Constraint:
	 *     contractEvent=ContractEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomContractEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_ATOM_CONTRACT_EVENT__CONTRACT_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_ATOM_CONTRACT_EVENT__CONTRACT_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getContractEventContractEventParserRuleCall_2_1_0(), semanticObject.getContractEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomObligationEvent
	 *     PointAtom returns PointAtomObligationEvent
	 *
	 * Constraint:
	 *     obligationEvent=ObligationEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomObligationEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_ATOM_OBLIGATION_EVENT__OBLIGATION_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_ATOM_OBLIGATION_EVENT__OBLIGATION_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getObligationEventObligationEventParserRuleCall_1_1_0(), semanticObject.getObligationEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomParameterDotExpression
	 *     PointAtom returns PointAtomParameterDotExpression
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomParameterDotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_ATOM_PARAMETER_DOT_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_ATOM_PARAMETER_DOT_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getVariableVariableDotExpressionParserRuleCall_0_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomPowerEvent
	 *     PointAtom returns PointAtomPowerEvent
	 *
	 * Constraint:
	 *     powerEvent=PowerEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomPowerEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_ATOM_POWER_EVENT__POWER_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_ATOM_POWER_EVENT__POWER_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getPowerEventPowerEventParserRuleCall_3_1_0(), semanticObject.getPowerEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointFunction
	 *     PointFunction returns PointFunction
	 *
	 * Constraint:
	 *     (name=PointFunctionName arg=PointExpression value=Timevalue timeUnit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_PointFunction(ISerializationContext context, PointFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__ARG));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__VALUE));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__TIME_UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT_FUNCTION__TIME_UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointFunctionAccess().getNamePointFunctionNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPointFunctionAccess().getArgPointExpressionParserRuleCall_3_0(), semanticObject.getArg());
		feeder.accept(grammarAccess.getPointFunctionAccess().getValueTimevalueParserRuleCall_5_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getPointFunctionAccess().getTimeUnitTimeUnitParserRuleCall_7_0(), semanticObject.getTimeUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     pointExpression=PointExpression
	 * </pre>
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POINT__POINT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POINT__POINT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getPointExpressionPointExpressionParserRuleCall_0(), semanticObject.getPointExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns PowerEvent
	 *     PowerEvent returns PowerEvent
	 *
	 * Constraint:
	 *     (eventName=PowerEventName powerVariable=[Power|ID])
	 * </pre>
	 */
	protected void sequence_PowerEvent(ISerializationContext context, PowerEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_EVENT__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_EVENT__POWER_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_EVENT__POWER_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerEventAccess().getEventNamePowerEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getPowerEventAccess().getPowerVariablePowerIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.POWER_EVENT__POWER_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractResumed
	 *
	 * Constraint:
	 *     (action='Resumed' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractResumed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_RESUMED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_RESUMED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionResumedKeyword_6_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_6_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractSuspended
	 *
	 * Constraint:
	 *     (action='Suspended' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractSuspended semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_SUSPENDED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_SUSPENDED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionSuspendedKeyword_5_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_5_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractTerminated
	 *
	 * Constraint:
	 *     (action='Terminated' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractTerminated semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_TERMINATED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_CONTRACT_TERMINATED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTerminatedKeyword_7_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_7_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationDischarged
	 *
	 * Constraint:
	 *     (action='Discharged' norm=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationDischarged semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionDischargedKeyword_2_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationIDTerminalRuleCall_2_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationResumed
	 *
	 * Constraint:
	 *     (action='Resumed' norm=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationResumed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_RESUMED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_RESUMED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionResumedKeyword_1_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationIDTerminalRuleCall_1_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PF_OBLIGATION_RESUMED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationSuspended
	 *
	 * Constraint:
	 *     (action='Suspended' norm=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationSuspended semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionSuspendedKeyword_0_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationIDTerminalRuleCall_0_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationTerminated
	 *
	 * Constraint:
	 *     (action='Terminated' norm=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationTerminated semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_TERMINATED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_TERMINATED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTerminatedKeyword_3_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationIDTerminalRuleCall_3_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PF_OBLIGATION_TERMINATED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationTriggered
	 *
	 * Constraint:
	 *     (action='Triggered' norm=[Obligation|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationTriggered semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTriggeredKeyword_4_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationIDTerminalRuleCall_4_4_0_1(), semanticObject.eGet(SymboleoPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns PowerState
	 *     PowerState returns PowerState
	 *
	 * Constraint:
	 *     (stateName=PowerStateName powerVariable=[Power|ID])
	 * </pre>
	 */
	protected void sequence_PowerState(ISerializationContext context, PowerState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.SITUATION__STATE_NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.POWER_STATE__POWER_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.POWER_STATE__POWER_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerStateAccess().getStateNamePowerStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.accept(grammarAccess.getPowerStateAccess().getPowerVariablePowerIDTerminalRuleCall_3_0_1(), semanticObject.eGet(SymboleoPackage.Literals.POWER_STATE__POWER_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Power returns Power
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         trigger=Proposition? 
	 *         creditor=VariableDotExpression 
	 *         debtor=VariableDotExpression 
	 *         antecedent=Proposition 
	 *         consequent=PowerFunction
	 *     )
	 * </pre>
	 */
	protected void sequence_Power(ISerializationContext context, Power semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionAssignment
	 *
	 * Constraint:
	 *     (name='HappensAssign' event=Event (assignment+=OAssignment assignment+=OAssignment*)?)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionAssignmentOnly
	 *
	 * Constraint:
	 *     (name='Assign' (assignment+=OAssignment assignment+=OAssignment*)?)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionAssignmentOnly semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappens
	 *
	 * Constraint:
	 *     (name='Happens' event=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappens semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_0_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappensAfter
	 *
	 * Constraint:
	 *     (name='HappensAfter' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappensAfter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensAfterKeyword_6_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_6_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_6_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappensWithin
	 *
	 * Constraint:
	 *     (name='HappensWithin' event=Event interval=Interval)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappensWithin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensWithinKeyword_3_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_3_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getIntervalIntervalParserRuleCall_3_5_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionOccurs
	 *
	 * Constraint:
	 *     (name='Occurs' situation=Situation interval=Interval)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionOccurs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_OCCURS__SITUATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_OCCURS__SITUATION));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_OCCURS__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_OCCURS__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameOccursKeyword_7_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getSituationSituationParserRuleCall_7_3_0(), semanticObject.getSituation());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getIntervalIntervalParserRuleCall_7_5_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionSHappensBefore
	 *
	 * Constraint:
	 *     (name='ShappensBefore' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionSHappensBefore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameShappensBeforeKeyword_2_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_2_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_2_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionSHappensBeforeEvent
	 *
	 * Constraint:
	 *     (name='ShappensBeforeE' event1=Event event2=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionSHappensBeforeEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameShappensBeforeEKeyword_5_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent1EventParserRuleCall_5_3_0(), semanticObject.getEvent1());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent2EventParserRuleCall_5_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionWHappensBefore
	 *
	 * Constraint:
	 *     (name='WhappensBefore' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionWHappensBefore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameWhappensBeforeKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_1_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_1_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionWHappensBeforeEvent
	 *
	 * Constraint:
	 *     (name='WhappensBeforeE' event1=Event event2=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionWHappensBeforeEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameWhappensBeforeEKeyword_4_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent1EventParserRuleCall_4_3_0(), semanticObject.getEvent1());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent2EventParserRuleCall_4_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NegatedPrimaryExpression
	 *     Or returns NegatedPrimaryExpression
	 *     Or.Or_1_0 returns NegatedPrimaryExpression
	 *     And returns NegatedPrimaryExpression
	 *     And.And_1_0 returns NegatedPrimaryExpression
	 *     Equality returns NegatedPrimaryExpression
	 *     Equality.Equality_1_0 returns NegatedPrimaryExpression
	 *     Comparison returns NegatedPrimaryExpression
	 *     Comparison.Comparison_1_0 returns NegatedPrimaryExpression
	 *     Addition returns NegatedPrimaryExpression
	 *     Addition.Plus_1_0_0_0 returns NegatedPrimaryExpression
	 *     Addition.Minus_1_0_1_0 returns NegatedPrimaryExpression
	 *     Multiplication returns NegatedPrimaryExpression
	 *     Multiplication.Multi_1_0_0_0 returns NegatedPrimaryExpression
	 *     Multiplication.Div_1_0_1_0 returns NegatedPrimaryExpression
	 *     PrimaryExpression returns NegatedPrimaryExpression
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, NegatedPrimaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.NEGATED_PRIMARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.NEGATED_PRIMARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PrimaryExpressionFunctionCall
	 *     Or returns PrimaryExpressionFunctionCall
	 *     Or.Or_1_0 returns PrimaryExpressionFunctionCall
	 *     And returns PrimaryExpressionFunctionCall
	 *     And.And_1_0 returns PrimaryExpressionFunctionCall
	 *     Equality returns PrimaryExpressionFunctionCall
	 *     Equality.Equality_1_0 returns PrimaryExpressionFunctionCall
	 *     Comparison returns PrimaryExpressionFunctionCall
	 *     Comparison.Comparison_1_0 returns PrimaryExpressionFunctionCall
	 *     Addition returns PrimaryExpressionFunctionCall
	 *     Addition.Plus_1_0_0_0 returns PrimaryExpressionFunctionCall
	 *     Addition.Minus_1_0_1_0 returns PrimaryExpressionFunctionCall
	 *     Multiplication returns PrimaryExpressionFunctionCall
	 *     Multiplication.Multi_1_0_0_0 returns PrimaryExpressionFunctionCall
	 *     Multiplication.Div_1_0_1_0 returns PrimaryExpressionFunctionCall
	 *     PrimaryExpression returns PrimaryExpressionFunctionCall
	 *
	 * Constraint:
	 *     function=FunctionCall
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpressionFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PRIMARY_EXPRESSION_FUNCTION_CALL__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PRIMARY_EXPRESSION_FUNCTION_CALL__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getFunctionFunctionCallParserRuleCall_1_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PrimaryExpressionRecursive
	 *     Or returns PrimaryExpressionRecursive
	 *     Or.Or_1_0 returns PrimaryExpressionRecursive
	 *     And returns PrimaryExpressionRecursive
	 *     And.And_1_0 returns PrimaryExpressionRecursive
	 *     Equality returns PrimaryExpressionRecursive
	 *     Equality.Equality_1_0 returns PrimaryExpressionRecursive
	 *     Comparison returns PrimaryExpressionRecursive
	 *     Comparison.Comparison_1_0 returns PrimaryExpressionRecursive
	 *     Addition returns PrimaryExpressionRecursive
	 *     Addition.Plus_1_0_0_0 returns PrimaryExpressionRecursive
	 *     Addition.Minus_1_0_1_0 returns PrimaryExpressionRecursive
	 *     Multiplication returns PrimaryExpressionRecursive
	 *     Multiplication.Multi_1_0_0_0 returns PrimaryExpressionRecursive
	 *     Multiplication.Div_1_0_1_0 returns PrimaryExpressionRecursive
	 *     PrimaryExpression returns PrimaryExpressionRecursive
	 *
	 * Constraint:
	 *     inner=Expression
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpressionRecursive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.PRIMARY_EXPRESSION_RECURSIVE__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.PRIMARY_EXPRESSION_RECURSIVE__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getInnerExpressionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainType returns RegularType
	 *     RegularType returns RegularType
	 *
	 * Constraint:
	 *     (
	 *         (name=ID ontologyType=OntologyType (attributes+=Attribute* attributes+=Attribute)?) | 
	 *         (name=ID regularType=[RegularType|ID] (attributes+=Attribute* attributes+=Attribute)?)
	 *     )
	 * </pre>
	 */
	protected void sequence_RegularType(ISerializationContext context, RegularType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns OneArgStringFunction
	 *     StringFunction returns OneArgStringFunction
	 *
	 * Constraint:
	 *     (
	 *         (name='String.toLowerCase' | name='String.toUpperCase' | name='String.trimEnd' | name='String.trimStart' | name='String.trim') 
	 *         arg1=Expression
	 *     )
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, OneArgStringFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns ThreeArgStringFunction
	 *     StringFunction returns ThreeArgStringFunction
	 *
	 * Constraint:
	 *     ((name='String.substring' | name='String.replaceAll') arg1=Expression arg2=Expression arg3=Expression)
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, ThreeArgStringFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns TwoArgStringFunction
	 *     StringFunction returns TwoArgStringFunction
	 *
	 * Constraint:
	 *     (name='String.concat' arg1=Expression arg2=Expression)
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, TwoArgStringFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.TWO_ARG_STRING_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.TWO_ARG_STRING_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringFunctionAccess().getNameStringConcatKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStringFunctionAccess().getArg1ExpressionParserRuleCall_1_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getStringFunctionAccess().getArg2ExpressionParserRuleCall_1_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timevalue returns TimevalueInt
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Timevalue(ISerializationContext context, TimevalueInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.TIMEVALUE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.TIMEVALUE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimevalueAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timevalue returns TimevalueVariable
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_Timevalue(ISerializationContext context, TimevalueVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.TIMEVALUE_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.TIMEVALUE_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimevalueAccess().getVariableVariableDotExpressionParserRuleCall_1_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDotExpression returns VariableDotExpression
	 *     VariableDotExpression.VariableDotExpression_1_0 returns VariableDotExpression
	 *
	 * Constraint:
	 *     (ref=VariableDotExpression_VariableDotExpression_1_0 tail=[Attribute|ID])
	 * </pre>
	 */
	protected void sequence_VariableDotExpression(ISerializationContext context, VariableDotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.VARIABLE_DOT_EXPRESSION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.VARIABLE_DOT_EXPRESSION__REF));
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.VARIABLE_DOT_EXPRESSION__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.VARIABLE_DOT_EXPRESSION__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDotExpressionAccess().getVariableDotExpressionRefAction_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getVariableDotExpressionAccess().getTailAttributeIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(SymboleoPackage.Literals.VARIABLE_DOT_EXPRESSION__TAIL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns VariableEvent
	 *     VariableEvent returns VariableEvent
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_VariableEvent(ISerializationContext context, VariableEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.VARIABLE_EVENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.VARIABLE_EVENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableEventAccess().getVariableVariableDotExpressionParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDotExpression returns VariableRef
	 *     VariableDotExpression.VariableDotExpression_1_0 returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=ID
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID type=[RegularType|ID] (attributes+=Assignment attributes+=Assignment*)?)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
